// Card Glow Effect for Cocos Creator 3.x
// Adds a rim light / edge glow effect to sprites

CCEffect %{
  techniques:
  - passes:
    - vert: sprite-vs:vert
      frag: sprite-fs:frag
      depthStencilState:
        depthTest: false
        depthWrite: false
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendSrcAlpha: src_alpha
          blendDstAlpha: one_minus_src_alpha
      rasterizerState:
        cullMode: none
      properties:
        alphaThreshold: { value: 0.5 }
        glowColor: { value: [1.0, 0.95, 0.7, 1.0], editor: { type: color } }
        glowWidth: { value: 0.015, range: [0.0, 0.1, 0.001] }
        glowIntensity: { value: 1.2, range: [0.0, 3.0, 0.1] }
}%

CCProgram sprite-vs %{
  precision highp float;
  #include <builtin/uniforms/cc-global>
  #if USE_LOCAL
    #include <builtin/uniforms/cc-local>
  #endif
  #if SAMPLE_FROM_RT
    #include <common/common-define>
  #endif

  in vec3 a_position;
  in vec2 a_texCoord;
  in vec4 a_color;

  out vec4 color;
  out vec2 uv0;

  vec4 vert () {
    vec4 pos = vec4(a_position, 1);

    #if USE_LOCAL
      pos = cc_matWorld * pos;
    #endif

    #if USE_PIXEL_ALIGNMENT
      pos = cc_matView * pos;
      pos.xyz = floor(pos.xyz);
      pos = cc_matProj * pos;
    #else
      pos = cc_matViewProj * pos;
    #endif

    uv0 = a_texCoord;
    #if SAMPLE_FROM_RT
      CC_HANDLE_RT_SAMPLE_FLIP(uv0);
    #endif
    color = a_color;

    return pos;
  }
}%

CCProgram sprite-fs %{
  precision highp float;
  #include <builtin/internal/embedded-alpha>
  #include <builtin/internal/alpha-test>

  in vec4 color;
  in vec2 uv0;

  uniform sampler2D cc_spriteTexture;

  uniform Constant {
    vec4 glowColor;
    float glowWidth;
    float glowIntensity;
  };

  vec4 frag () {
    vec4 texColor = CCSampleWithAlphaSeparated(cc_spriteTexture, uv0);

    // Sample neighboring pixels to detect edges
    float offset = glowWidth;

    // Sample in 8 directions for edge detection
    float alphaSum = 0.0;
    alphaSum += CCSampleWithAlphaSeparated(cc_spriteTexture, uv0 + vec2(offset, 0.0)).a;
    alphaSum += CCSampleWithAlphaSeparated(cc_spriteTexture, uv0 + vec2(-offset, 0.0)).a;
    alphaSum += CCSampleWithAlphaSeparated(cc_spriteTexture, uv0 + vec2(0.0, offset)).a;
    alphaSum += CCSampleWithAlphaSeparated(cc_spriteTexture, uv0 + vec2(0.0, -offset)).a;
    alphaSum += CCSampleWithAlphaSeparated(cc_spriteTexture, uv0 + vec2(offset, offset)).a;
    alphaSum += CCSampleWithAlphaSeparated(cc_spriteTexture, uv0 + vec2(-offset, offset)).a;
    alphaSum += CCSampleWithAlphaSeparated(cc_spriteTexture, uv0 + vec2(offset, -offset)).a;
    alphaSum += CCSampleWithAlphaSeparated(cc_spriteTexture, uv0 + vec2(-offset, -offset)).a;

    // Calculate edge factor (higher at edges where alpha changes)
    float edgeFactor = abs(texColor.a * 8.0 - alphaSum) / 8.0;

    // Apply glow at edges
    vec4 finalColor = texColor * color;

    // Add glow effect - blend glow color at edges
    float glowAmount = edgeFactor * glowIntensity;
    finalColor.rgb = mix(finalColor.rgb, glowColor.rgb * glowIntensity, glowAmount * 0.5);

    // Also add a subtle overall rim light effect
    // Brighten edges based on distance from center
    vec2 centerDist = abs(uv0 - vec2(0.5, 0.5)) * 2.0;
    float rimFactor = max(centerDist.x, centerDist.y);
    rimFactor = smoothstep(0.7, 1.0, rimFactor);

    finalColor.rgb += glowColor.rgb * rimFactor * glowIntensity * 0.3 * texColor.a;

    ALPHA_TEST(finalColor);
    return finalColor;
  }
}%
